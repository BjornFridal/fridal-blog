---
title: 'Let''s build a Redux Clone'
teaser: '...'
pubDate: null
description: '...'
author: 'Bjørn Fridal'
image: './interactive-redux-flowchart.png'
imageAlt: 'Interactive Redux Flow Chart'
tags: ['react', 'redux']
---

#### To get a better understanding of how Redux works we are going to build a simplified Redux clone from scratch. To visualize how Redux works, I've made an interactive flow chart to go along with this blog post. Have fun!

## Isn't Redux like… old?
Redux was first released way back in 2015 and since then we have seen plenty of new ways to manage state in React. We have Context, Zustand, Jotai and XState just to name a few. Does it even make sense then to spend time learning about Grampa Redux, then?

For a lot of simpler applications, React's Context will probably suffice, however, as we will see in this blog post, the real strength of Redux comes when we leverage it's middleware feature. Middleware is something Context doesn't support out-of-the-box. Besides, there are thousands of React apps in the wild that are built using with Redux, so chances are good that you will eventually work on a project with Redux. So yes, Redux maybe old, but it's definitely still worth understanding how it works.

## What is Redux?
In short Redux is a state management library. It is most often used in React applications, but it is actually framework agnostic. Once we integrate Redux with React we have an easy and predictable way to access and update state from anywhere in our application. And with Redux middleware we will be able to handle operations related to our state such as fetching data from an API and placing it into Redux, logging Redux state etc.

## How does Redux work?
In Redux we always have a single `store` and that store contains our state. The store allows us to `subscribe` to changes made to the state and it allows us to update the state by sending an `action` to the store. We do that using the `dispatch` method. A dispatched action will first go through any `middleware` the store has and then through the store's `reducer` where it will update existing state and return new state to all subscribers. An action can also dispatch new actions along the way 

## What we will build
We will build our own standalone version of Redux. Even though our Redux Clone will be a simplified version of the [real deal](https://redux.js.org/), it will have all of the fundamentals including middleware and integration with React. That way we have everything we need to get a deep understanding of how Redux works. 

Since Redux is most often used with React, we will drop our Redux Clone into a small React application. The only thing the application does is 1) fetch a random Pokémon from an external API and 2) display the Pokémon on the screen. We will then use the Redux Clone to manage the state.

I assume that you already familiar with React, Reducers and Context. If not, I hope you're a fast learner :)

## Application Step-by-Step
Here's a step-by-step breakdown of how our React application will use the Redux Clone.

1) A user is presented with our UI. The UI contains a `Fetch Pokemon` button and a status text that says `No Pokemon`.
2) The user click's the `Fetch Pokemon` button.
3) We `dispatch` an `action` of type `fetch`.
4) The `store`receives our `action` and runs it through the `middleware`.
5) The `thunk-middleware` sees that the action has a `fetch` method and invokes it.
6) The `fetch` method makes an async call to an API. Since the API may be slow to respond we `dispatch` an `action` of type `fetching`.
7) The new fetching `action` is also run through the store's middleware, but nothing happens since it has no method that can be invoked by the `thunk-middleware`.
8) The `action` then runs through the `reducer` and updates the "status" state.
9) Since our UI (React) is `subscribed` to the store it receives the new state and accordingly changes the status text to `Fetching...`.
10) Eventually the API responds to our request and returns the Pokémon data. We `dispatch` a new `action` of type `fetched` and this time we include the Pokémon data as a payload.
11) Like before, our `actions` first runs through the `middleware`, but again there's no action method to be invoked.
12) The `action` proceeds to the `reducer` and here it now updates the "status" and the "pokemon" properties.
13) Again our UI receives the updated state from the store and can now show the Pokémon we fetched from the API.

## Interactive flow chart
That's a lot of steps to wrap your head around. To make it easier I build this fancy interactive flow chart. Click the button and each step will be shown.

<div class="xl:h-[760px] xl:relative"><div class="border border-purple-100 rounded-lg overflow-hidden xl:absolute xl:h-[760px] xl:w-[630px] px-4 xl:px-8 xl:left-[50%] xl:-translate-x-1/2 "><iframe class="aspect-[141/190] w-full" src="https://rive.app/community/6398-12512-redux-clone-flow-chart/embed" allowfullscreen></iframe></div></div>

## The Store
Now that we know exactly what we are building, let's get coding! I mentioned that we always have a `store` in Redux and that's where we will start.

```js
createStore = (reducer, initialState) => {
  const store = {
    state: initialState,
    listeners: [],
    getState: () => store.state,
    subscribe: (listener) => {
      store.listeners.push(listener);

      return () => {
        const index = store.listeners.indexOf(listener);
        store.listeners.splice(index, 1);
      };
    },
    dispatch: (action) => {
      store.state = reducer(store.state, action);
      store.listeners.forEach((listener) => listener());
    }
  };

  return store;
};
```

Instead of going though the `createStore` function line by line (use ChatGPT for that), I will zoom in on the most important parts; subscribe and dispatch.

#### Subscribe
The `subscribe` method allows other XXX to "listen" to changes in the store's state. When the store's state updates, all subscribed listeners are notified. In our case it will be React Components that subscribe to the store.

#### Dispatch
 The `dispatch` method is used to send, or "dispatch", actions to the store. When an action is dispatched, the store uses the reducer to determine how the state should change in response to that action. After the state is updated, all subscribed listeners are called, notifying them of the change.

 The `createStore` function is the core of our Redux Clone. We can use it in different applications without changing it. What will change from application to application is the two parameters in takes: Initial State (to initialize our store's state) and Reducers. 

## Reducer
The store in our Redux Clone expects a single reducer (in the real Redux a store can have multiple reducers). The reducer is passed into the store as an argument to `createStore`.

```js
const reducer = (state, action) => {
  switch (action.type) {
    case 'idle':
      return { ...state, status: 'idle' };

    case 'fetching':
      return { ...state, status: 'fetching', pokemon: null };

    case 'fetched':
      return { ...state, status: 'fetched', pokemon: action.payload };

    default:
      return state;
  }
};
```
As you can see it's an ordinary reducer. Any action dispatched to the store will go through the reducer and return a new object with the updated state.

By now we are able to create a fully functioning Redux store:
```js
const initialState = { status: 'idle', pokemon: null };
const store = createStore(reducer, initialState);
```

Since we need the store to work in our Pokémon application we need a way to integrate it with React.

## React Integration
We can use React's Context to make the store available throughout our application.

```jsx
const ReduxContext = createContext();

const ReduxProvider = ({ children, store }) => (
  <ReduxContext.Provider value={store}>
    {children}
  </ReduxContext.Provider>
);
```

Now that we can access the store in our components, we need an easy way to get the store's state. Both when our component mounts, but also when the store's state is updated. Maybe a small hook?

```jsx
const useSelector = (selector) => {
  const store = useContext(ReduxContext);
  const [state, setState] = useState(selector(store.getState()));

  useEffect(() => {
    const unsubscribe = store.subscribe(() => {
      const newState = selector(store.getState());
      setState(newState);
    });

    return () => {
      unsubscribe();
    };
  }, [selector, store]);

  return state;
};
```


The `selector` parameter is a callback function that, when given the store's state, extracts and returns a specific slice of that state.

Inside `useEffect`, we `subscribe` to changes in the store. When the store's state changes, we update our local state with `setState`, causing our component to rerender with the new state.

Let's also create a hook to access the store's `dispatch` method.

```jsx
const useDispatch = () => {
  const store = useContext(ReduxContext);
  return store.dispatch;
};
```

With our React integration in place we now have everything we need to run our application. Are you excited? 

<a class="bg-pink-100 h-36 rounded flex flex-col leading-none justify-center items-center w-full border-none [&>*]:m-0 gap-y-2" href="https://stackblitz.com/github/BjornFridal/redux-clone/tree/basic?file=src%2FApp.jsx" target="_blank">
  <h3 class="font-bold">Will it run?</h3>
  <img class="h-8" src="https://developer.stackblitz.com/img/open_in_stackblitz.svg" alt="Open in StackBlitz" />
  <p class="font-semibold text-xs">( version without middleware )</p>
</a>


## Middleware